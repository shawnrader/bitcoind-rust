#![allow(non_snake_case)]
#![allow(dead_code)]

use super::secp256k1_scalar;
/*
 * Both lambda and beta are primitive cube roots of unity.  That is lamba^3 == 1 mod n and
 * beta^3 == 1 mod p, where n is the curve order and p is the field order.
 *
 * Furthermore, because (X^3 - 1) = (X - 1)(X^2 + X + 1), the primitive cube roots of unity are
 * roots of X^2 + X + 1.  Therefore lambda^2 + lamba == -1 mod n and beta^2 + beta == -1 mod p.
 * (The other primitive cube roots of unity are lambda^2 and beta^2 respectively.)
 *
 * Let l = -1/2 + i*sqrt(3)/2, the complex root of X^2 + X + 1. We can define a ring
 * homomorphism phi : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n. The kernel of phi
 * is a lattice over Z[l] (considering Z[l] as a Z-module). This lattice is generated by a
 * reduced basis {a1 + b1*l, a2 + b2*l} where
 *
 * - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 * - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}
 * - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}
 * - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 *
 * "Guide to Elliptic Curve Cryptography" (Hankerson, Menezes, Vanstone) gives an algorithm
 * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1
 * and k2 are small in absolute value.
 *
 * The algorithm computes c1 = round(b2 * k / n) and c2 = round((-b1) * k / n), and gives
 * k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and
 * compute r2 = k2 mod n, and r1 = k1 mod n = (k - r2 * lambda) mod n, avoiding the need for
 * the constants a1 and a2.
 *
 * g1, g2 are precomputed constants used to replace division with a rounded multiplication
 * when decomposing the scalar for an endomorphism-based point multiplication.
 *
 * The possibility of using precomputed estimates is mentioned in "Guide to Elliptic Curve
 * Cryptography" (Hankerson, Menezes, Vanstone) in section 3.5.
 *
 * The derivation is described in the paper "Efficient Software Implementation of Public-Key
 * Cryptography on Sensor Networks Using the MSP430X Microcontroller" (Gouvea, Oliveira, Lopez),
 * Section 4.3 (here we use a somewhat higher-precision estimate):
 * d = a1*b2 - b1*a2
 * g1 = round(2^384 * b2/d)
 * g2 = round(2^384 * (-b1)/d)
 *
 * (Note that d is also equal to the curve order, n, here because [a1,b1] and [a2,b2]
 * can be found as outputs of the Extended Euclidean Algorithm on inputs n and lambda).
 *
 * The function below splits k into r1 and r2, such that
 * - r1 + lambda * r2 == k (mod n)
 * - either r1 < 2^128 or -r1 mod n < 2^128
 * - either r2 < 2^128 or -r2 mod n < 2^128
 *
 * See proof below.
 */
pub fn secp256k1_scalar_split_lambda(
    r1: &mut secp256k1_scalar,
    r2: &mut secp256k1_scalar,
    k: &secp256k1_scalar,
) {
    let mut c1 = secp256k1_scalar::default();
    let mut c2 = secp256k1_scalar::default();

    static MINUS_B1: secp256k1_scalar = secp256k1_scalar::from_raw([
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
        0xE4437ED6, 0x010E8828, 0x6F547FA9, 0x0ABFE4C3,
    ]);

    static MINUS_B2: secp256k1_scalar = secp256k1_scalar::from_raw([
        0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE,
        0x8A280AC5, 0x0774346D, 0xD765CDA8, 0x3DB1562C,
    ]);

    static G1: secp256k1_scalar = secp256k1_scalar::from_raw([
        0x3086D221, 0xA7D46BCD, 0xE86C90E4, 0x9284EB15,
        0x3DAA8A14, 0x71E8CA7F, 0xE893209A, 0x45DBB031,
    ]);

    static G2: secp256k1_scalar = secp256k1_scalar::from_raw([
        0xE4437ED6, 0x010E8828, 0x6F547FA9, 0x0ABFE4C4,
        0x221208AC, 0x9DF506C6, 0x1571B4AE, 0x8AC47F71,
    ]);

    debug_assert!(k.is_valid(), "SECP256K1_SCALAR_VERIFY failed");
    debug_assert!(r1 as *const _ != k as *const _, "r1 != k check failed");
    debug_assert!(r2 as *const _ != k as *const _, "r2 != k check failed");
    debug_assert!(r1 as *const _ != r2 as *const _, "r1 != r2 check failed");

    // these _var calls are constant time since the shift amount is constant
    secp256k1_scalar_mul_shift_var(&mut c1, k, &G1, 384);
    secp256k1_scalar_mul_shift_var(&mut c2, k, &G2, 384);
    secp256k1_scalar_mul(&mut c1, &c1, &MINUS_B1);
    secp256k1_scalar_mul(&mut c2, &c2, &MINUS_B2);
    secp256k1_scalar_add(r2, &c1, &c2);
    secp256k1_scalar_mul(r1, r2, &secp256k1_const_lambda);
    secp256k1_scalar_negate(r1, r1);
    secp256k1_scalar_add(r1, r1, k);

    debug_assert!(r1.is_valid(), "SECP256K1_SCALAR_VERIFY failed");
    debug_assert!(r2.is_valid(), "SECP256K1_SCALAR_VERIFY failed");

    #[cfg(feature = "verify")]
    secp256k1_scalar_split_lambda_verify(r1, r2, k);
}
