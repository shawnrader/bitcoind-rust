#![allow(non_snake_case)]
#![allow(dead_code)]

use crate::secp256k1::scalar_4x64::{
    secp256k1_scalar,
    secp256k1_scalar_mul_shift_var,
    secp256k1_scalar_mul,
    secp256k1_scalar_add,
    secp256k1_scalar_negate,
    secp256k1_scalar_set_b32,
    secp256k1_scalar_is_zero,
    secp256k1_scalar_get_b32,
    secp256k1_scalar_eq,
};
use crate::secp256k1::util::secp256k1_memcmp_var;
use crate::SECP256K1_SCALAR_CONST;
use crate::VERIFY_CHECK;



pub const secp256k1_scalar_one: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0, 0, 0, 0, 0, 0, 0, 1);
pub const secp256k1_scalar_zero: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0, 0, 0, 0, 0, 0, 0, 0);


pub fn secp256k1_scalar_set_b32_seckey(r: &mut secp256k1_scalar, bin: &[u8; 32]) -> i32 {
    let mut overflow: i32 = 0;
    secp256k1_scalar_set_b32(r, bin, &mut overflow);
    return ((overflow == 0) && secp256k1_scalar_is_zero(r) == 0) as i32;
}

pub const secp256k1_const_lambda: secp256k1_scalar = SECP256K1_SCALAR_CONST!( 
    0x5363AD4C, 0xC05C30E0, 0xA5261C02, 0x8812645A,
    0x122E22EA, 0x20816678, 0xDF02967C, 0x1B23BD72
);

/*
 * Both lambda and beta are primitive cube roots of unity.  That is lamba^3 == 1 mod n and
 * beta^3 == 1 mod p, where n is the curve order and p is the field order.
 *
 * Furthermore, because (X^3 - 1) = (X - 1)(X^2 + X + 1), the primitive cube roots of unity are
 * roots of X^2 + X + 1.  Therefore lambda^2 + lamba == -1 mod n and beta^2 + beta == -1 mod p.
 * (The other primitive cube roots of unity are lambda^2 and beta^2 respectively.)
 *
 * Let l = -1/2 + i*sqrt(3)/2, the complex root of X^2 + X + 1. We can define a ring
 * homomorphism phi : Z[l] -> Z_n where phi(a + b*l) == a + b*lambda mod n. The kernel of phi
 * is a lattice over Z[l] (considering Z[l] as a Z-module). This lattice is generated by a
 * reduced basis {a1 + b1*l, a2 + b2*l} where
 *
 * - a1 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 * - b1 =     -{0xe4,0x43,0x7e,0xd6,0x01,0x0e,0x88,0x28,0x6f,0x54,0x7f,0xa9,0x0a,0xbf,0xe4,0xc3}
 * - a2 = {0x01,0x14,0xca,0x50,0xf7,0xa8,0xe2,0xf3,0xf6,0x57,0xc1,0x10,0x8d,0x9d,0x44,0xcf,0xd8}
 * - b2 =      {0x30,0x86,0xd2,0x21,0xa7,0xd4,0x6b,0xcd,0xe8,0x6c,0x90,0xe4,0x92,0x84,0xeb,0x15}
 *
 * "Guide to Elliptic Curve Cryptography" (Hankerson, Menezes, Vanstone) gives an algorithm
 * (algorithm 3.74) to find k1 and k2 given k, such that k1 + k2 * lambda == k mod n, and k1
 * and k2 are small in absolute value.
 *
 * The algorithm computes c1 = round(b2 * k / n) and c2 = round((-b1) * k / n), and gives
 * k1 = k - (c1*a1 + c2*a2) and k2 = -(c1*b1 + c2*b2). Instead, we use modular arithmetic, and
 * compute r2 = k2 mod n, and r1 = k1 mod n = (k - r2 * lambda) mod n, avoiding the need for
 * the constants a1 and a2.
 *
 * g1, g2 are precomputed constants used to replace division with a rounded multiplication
 * when decomposing the scalar for an endomorphism-based point multiplication.
 *
 * The possibility of using precomputed estimates is mentioned in "Guide to Elliptic Curve
 * Cryptography" (Hankerson, Menezes, Vanstone) in section 3.5.
 *
 * The derivation is described in the paper "Efficient Software Implementation of Public-Key
 * Cryptography on Sensor Networks Using the MSP430X Microcontroller" (Gouvea, Oliveira, Lopez),
 * Section 4.3 (here we use a somewhat higher-precision estimate):
 * d = a1*b2 - b1*a2
 * g1 = round(2^384 * b2/d)
 * g2 = round(2^384 * (-b1)/d)
 *
 * (Note that d is also equal to the curve order, n, here because [a1,b1] and [a2,b2]
 * can be found as outputs of the Extended Euclidean Algorithm on inputs n and lambda).
 *
 * The function below splits k into r1 and r2, such that
 * - r1 + lambda * r2 == k (mod n)
 * - either r1 < 2^128 or -r1 mod n < 2^128
 * - either r2 < 2^128 or -r2 mod n < 2^128
 *
 * See proof below.
 */
pub fn secp256k1_scalar_split_lambda(
    r1: &mut secp256k1_scalar,
    r2: &mut secp256k1_scalar,
    k: &secp256k1_scalar,
) {
    let mut c1 = secp256k1_scalar::new();
    let mut c2 = secp256k1_scalar::new();

    let MINUS_B1: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xE4437ED6, 0x010E8828, 0x6F547FA9, 0x0ABFE4C3);
    let MINUS_B2: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0x8A280AC5, 0x0774346D, 0xD765CDA8, 0x3DB1562C);
    let G1: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0x3086D221, 0xA7D46BCD, 0xE86C90E4, 0x9284EB15, 0x3DAA8A14, 0x71E8CA7F, 0xE893209A, 0x45DBB031);
    let G2: secp256k1_scalar = SECP256K1_SCALAR_CONST!(0xE4437ED6, 0x010E8828, 0x6F547FA9, 0x0ABFE4C4, 0x221208AC, 0x9DF506C6, 0x1571B4AE, 0x8AC47F71);

    debug_assert!(r1 as *const _ != k as *const _, "r1 != k check failed");
    debug_assert!(r2 as *const _ != k as *const _, "r2 != k check failed");
    debug_assert!(r1 as *const _ != r2 as *const _, "r1 != r2 check failed");

    // these _var calls are constant time since the shift amount is constant
    secp256k1_scalar_mul_shift_var(&mut c1, k, &G1, 384);
    secp256k1_scalar_mul_shift_var(&mut c2, k, &G2, 384);
    let c1_clone = c1.clone();
    secp256k1_scalar_mul(&mut c1, &c1_clone, &MINUS_B1);
    let c2_clone = c2.clone();
    secp256k1_scalar_mul(&mut c2, &c2_clone, &MINUS_B2);
    secp256k1_scalar_add(r2, &c1, &c2);
    secp256k1_scalar_mul(r1, r2, &secp256k1_const_lambda);
    let r1_clone = r1.clone();
    secp256k1_scalar_negate(r1, &r1_clone);
    let r1_clone = r1.clone();
    secp256k1_scalar_add(r1, &r1_clone, k);

    #[cfg(feature = "verify")]
    secp256k1_scalar_split_lambda_verify(r1, r2, k.clone());
}


/*
 * Proof for secp256k1_scalar_split_lambda's bounds.
 *
 * Let
 *  - epsilon1 = 2^256 * |g1/2^384 - b2/d|
 *  - epsilon2 = 2^256 * |g2/2^384 - (-b1)/d|
 *  - c1 = round(k*g1/2^384)
 *  - c2 = round(k*g2/2^384)
 *
 * Lemma 1: |c1 - k*b2/d| < 2^-1 + epsilon1
 *
 *    |c1 - k*b2/d|
 *  =
 *    |c1 - k*g1/2^384 + k*g1/2^384 - k*b2/d|
 * <=   {triangle inequality}
 *    |c1 - k*g1/2^384| + |k*g1/2^384 - k*b2/d|
 *  =
 *    |c1 - k*g1/2^384| + k*|g1/2^384 - b2/d|
 * <    {rounding in c1 and 0 <= k < 2^256}
 *    2^-1 + 2^256 * |g1/2^384 - b2/d|
 *  =   {definition of epsilon1}
 *    2^-1 + epsilon1
 *
 * Lemma 2: |c2 - k*(-b1)/d| < 2^-1 + epsilon2
 *
 *    |c2 - k*(-b1)/d|
 *  =
 *    |c2 - k*g2/2^384 + k*g2/2^384 - k*(-b1)/d|
 * <=   {triangle inequality}
 *    |c2 - k*g2/2^384| + |k*g2/2^384 - k*(-b1)/d|
 *  =
 *    |c2 - k*g2/2^384| + k*|g2/2^384 - (-b1)/d|
 * <    {rounding in c2 and 0 <= k < 2^256}
 *    2^-1 + 2^256 * |g2/2^384 - (-b1)/d|
 *  =   {definition of epsilon2}
 *    2^-1 + epsilon2
 *
 * Let
 *  - k1 = k - c1*a1 - c2*a2
 *  - k2 = - c1*b1 - c2*b2
 *
 * Lemma 3: |k1| < (a1 + a2 + 1)/2 < 2^128
 *
 *    |k1|
 *  =   {definition of k1}
 *    |k - c1*a1 - c2*a2|
 *  =   {(a1*b2 - b1*a2)/n = 1}
 *    |k*(a1*b2 - b1*a2)/n - c1*a1 - c2*a2|
 *  =
 *    |a1*(k*b2/n - c1) + a2*(k*(-b1)/n - c2)|
 * <=   {triangle inequality}
 *    a1*|k*b2/n - c1| + a2*|k*(-b1)/n - c2|
 * <    {Lemma 1 and Lemma 2}
 *    a1*(2^-1 + epslion1) + a2*(2^-1 + epsilon2)
 * <    {rounding up to an integer}
 *    (a1 + a2 + 1)/2
 * <    {rounding up to a power of 2}
 *    2^128
 *
 * Lemma 4: |k2| < (-b1 + b2)/2 + 1 < 2^128
 *
 *    |k2|
 *  =   {definition of k2}
 *    |- c1*a1 - c2*a2|
 *  =   {(b1*b2 - b1*b2)/n = 0}
 *    |k*(b1*b2 - b1*b2)/n - c1*b1 - c2*b2|
 *  =
 *    |b1*(k*b2/n - c1) + b2*(k*(-b1)/n - c2)|
 * <=   {triangle inequality}
 *    (-b1)*|k*b2/n - c1| + b2*|k*(-b1)/n - c2|
 * <    {Lemma 1 and Lemma 2}
 *    (-b1)*(2^-1 + epslion1) + b2*(2^-1 + epsilon2)
 * <    {rounding up to an integer}
 *    (-b1 + b2)/2 + 1
 * <    {rounding up to a power of 2}
 *    2^128
 *
 * Let
 *  - r2 = k2 mod n
 *  - r1 = k - r2*lambda mod n.
 *
 * Notice that r1 is defined such that r1 + r2 * lambda == k (mod n).
 *
 * Lemma 5: r1 == k1 mod n.
 *
 *    r1
 * ==   {definition of r1 and r2}
 *    k - k2*lambda
 * ==   {definition of k2}
 *    k - (- c1*b1 - c2*b2)*lambda
 * ==
 *    k + c1*b1*lambda + c2*b2*lambda
 * ==  {a1 + b1*lambda == 0 mod n and a2 + b2*lambda == 0 mod n}
 *    k - c1*a1 - c2*a2
 * ==  {definition of k1}
 *    k1
 *
 * From Lemma 3, Lemma 4, Lemma 5 and the definition of r2, we can conclude that
 *
 *  - either r1 < 2^128 or -r1 mod n < 2^128
 *  - either r2 < 2^128 or -r2 mod n < 2^128.
 *
 * Q.E.D.
 */
fn secp256k1_scalar_split_lambda_verify(r1: &mut secp256k1_scalar, r2: &mut secp256k1_scalar, k: secp256k1_scalar) {
    let mut s: secp256k1_scalar = secp256k1_scalar::new();
    let mut buf1 = [0u8; 32];
    let mut buf2 = [0u8; 32];

    /* (a1 + a2 + 1)/2 is 0xa2a8918ca85bafe22016d0b917e4dd77 */
    let k1_bound: [u8; 32] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xa2, 0xa8, 0x91, 0x8c, 0xa8, 0x5b, 0xaf, 0xe2, 0x20, 0x16, 0xd0, 0xb9, 0x17, 0xe4, 0xdd, 0x77
    ];

    /* (-b1 + b2)/2 + 1 is 0x8a65287bd47179fb2be08846cea267ed */
    let k2_bound: [u8; 32] = [
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x8a, 0x65, 0x28, 0x7b, 0xd4, 0x71, 0x79, 0xfb, 0x2b, 0xe0, 0x88, 0x46, 0xce, 0xa2, 0x67, 0xed
    ];

    secp256k1_scalar_mul(&mut s, &secp256k1_const_lambda, r2);
    let s1 = s.clone();
    secp256k1_scalar_add(&mut s, &s1, r1);
    VERIFY_CHECK!(secp256k1_scalar_eq(&s, &k) == 1);

    secp256k1_scalar_negate(&mut s, r1);
    secp256k1_scalar_get_b32(&mut buf1, r1);
    secp256k1_scalar_get_b32(&mut buf2, &mut s);
    VERIFY_CHECK!(secp256k1_memcmp_var(&buf1, &k1_bound, 32) < 0 || secp256k1_memcmp_var(&buf2, &k1_bound, 32) < 0);

    secp256k1_scalar_negate(&mut s, r2);
    secp256k1_scalar_get_b32(&mut buf1, r2);
    secp256k1_scalar_get_b32(&mut buf2, &mut s);
    VERIFY_CHECK!(secp256k1_memcmp_var(&buf1, &k2_bound, 32) < 0 || secp256k1_memcmp_var(&buf2, &k2_bound, 32) < 0);
}
